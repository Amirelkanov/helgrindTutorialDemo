## Демонстрация возможностей инструмента Helgrind

### Предисловие
Helgrind – это инструмент Valgrind для нахождения ошибок синхронизации в программах на
языках C++, C, Fortran, использующих примитивы потоков POSIX threads.

Использование:
```
valgrind --tool=helgrind [FLAGS] <EXECUTABLE>
```

1. В данном репозитории уже собраны таргеты Makefile'а для удобного запуска примеров:
   * `make hellgrind_default_check PROGRAM_NAME=<program_name>` - собирает указанный пример `program_name` и запускает исполняемый файл через helgrind
   * `make helgrind_verbose_check PROGRAM_NAME=<program_name>` - аналогичное поведение, только вывод helgrind'а будет более подробным
   * `make make_program PROGRAM_NAME=<program_name>` - собирает указанный пример `program_name`

2. Если хочется пересобрать QT-проект, находящийся в папке [qt_proj](qt_proj), и прогнать его через helgrind, то:
   * `cd qt_proj` - перейдем туда
   * `make` - пересоберем
   * `valgrind --tool=helgrind ./qt_proj` - прогоняем через helgrind

3. Если захочется запустить отладку с помощью gdb, вот примерные шаги, которые нужно предпринять для этого:
   1. Первая консоль:
      * `make make_program PROGRAM_NAME=<program_name>` - просто сборка программы
      * `valgrind --tool=helgrind --vgdb=yes --vgdb-error=0 <executable>` - пропускаем полученный первой командой исполняемый через helgrind, говоря helgrind'у, что хотим отлаживать код программы (`--vgdb=yes`), а также просим его приостановиться, перед тем как запускать программу, чтобы мы успели подключиться к GDB со второй консоли и, например, поставить всякие breakpoint'ы (` --vgdb-error=0`)
   2. Вторая консоль _(по факту, первая консоль подскажет, что надо сделать, но я продублирую)_:
      * `gdb ./<executable>`
      * `target remote | path-to-vgdb --pid=<PID>` 

### Примеры
1. [bad_unlock.c](bad_unlock.c) - различные ошибки при некорректной работе с POSIX API. Среди таких ошибок в этой программе допущены:
   * Разблокировка мьютекса, который и так разблокирован
   * Разблокировка мьютекса, который захвачен другим потоком
   * Завершение главного потока, который все еще держит лок
2. [cross_deadlock.c](cross_deadlock.c) - перекрестный дедлок. Должен сказать, что порядок захвата локов некорректен.
3. [dining_philosophers.c](dining_philosophers.c) - задача о 5 философах. Должен сказать, что порядок захвата локов некорректен. 
_Если он не показывает информацию о каждом локе - это нормально. Helgrind делает так, чтобы не нагружать пользователя однотонной информацией_
4. [recursive_lock.c](recursive_lock.c) - некорректная работа с рекурсивным мьютексом: рекурсивно захватили 3 раза, пытаемся освободить 4 раза. Должен сказать, что пытаемся освободить мьютекс, который уже и так освобожден.
5. [simple_data_race.c](simple_data_race.c) - простейший пример гонки данных. Должен определить эту гонку и показать 2 stacktrace'а для 1 ошибки, а не один. Оно и понятно: мы знаем, что гонка включает в себя два разных потока, обращающихся к одному и тому же месту таким образом, что результат зависит от относительных скоростей двух потоков.
6. [cond_var_destroy_while_being_waited.c](cond_var_destroy_while_being_waited.c) - некорректная работа с условными переменными. Должен сказать, что условная переменная была уничтожена во втором потоке, пока главный поток ждал сигнала от этой переменной
7. [bar_bad.c](bar_bad.c) - проверка на различные ошибки, связанные с барьером. Среди них:
    * Инициализация барьера с <<барьерным счетчиком>> равным 0. Оно и понятно, почему считается ошибкой: в таком случае просто получили проходной двор в мире потоков, ничего блокироваться не будет
    * Инициализация того же барьера дважды
    * Инициализация барьера, который имеет потоки, ждущие его. Тут еще будет ошибка, связанная с повторной инициализацией, но нас больше интересует указанная ошибка: мы создаем барьер, потом создаем поток, единственная цель которого - заблокироваться на барьере, ну и пробуем переинициализировать.
    * Уничтожение барьера, который имеет потоки, ждущие его. На этом шаге программа зависнет, т.к. она не сможет продолжить дальнейшее исполнение, пока барьер не уничтожиться, а для этого ему надо освободиться от вечнождущего потока (?!). Поэтому нам надо вмешаться, подав сигнал SIGINT с помощью `CTRL+C`. 
    Да, грязно: не освобождаем кучу, не закрываем потоки, но что поделаешь? Не надо такие ошибки допускать
1. В директории [qt_proj](qt_proj) собран простенький QT-проект, где в [main.cpp](qt_proj/main.cpp) реализован уже обговоренный выше перекрестный дедлок. Если мы его разрешим, задав порядок захвата, то все равно увидим ошибку, уже не относящуюся к дедлоку: `Thread #1: pthread_mutex_destroy with invalid argument`. Дело в том, что QT 4.X использует свои реализацию мьютексов QMutex и уничтожения потоков. Helgrind пытается заглушить false-positive'ы, связанные с использованием не POSIX'ого API, но не всегда ему это удается.
